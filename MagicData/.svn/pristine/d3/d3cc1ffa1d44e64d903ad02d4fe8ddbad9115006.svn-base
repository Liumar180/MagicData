package connectToTitan

import org.apache.spark.rdd.JdbcRDD
import org.apache.spark.rdd.RDD
import org.apache.spark.SparkConf
import org.apache.spark.SparkContext
import org.apache.spark.graphx._
import java.util.ArrayList
import java.sql.DriverManager
import org.apache.spark.rdd.RDD.rddToPairRDDFunctions
import com.thinkaurelius.titan.core.EdgeLabel
import com.thinkaurelius.titan.core.Multiplicity
import com.thinkaurelius.titan.core.PropertyKey
import com.thinkaurelius.titan.core.TitanFactory
import com.thinkaurelius.titan.core.TitanGraph
import com.thinkaurelius.titan.core.TitanTransaction
import com.thinkaurelius.titan.core.attribute.Geoshape
import com.thinkaurelius.titan.core.schema.ConsistencyModifier
import com.thinkaurelius.titan.core.schema.TitanGraphIndex
import com.thinkaurelius.titan.core.schema.TitanManagement
import com.thinkaurelius.titan.core.TitanVertex
import org.apache.tinkerpop.gremlin.process.traversal.Order
import org.apache.tinkerpop.gremlin.structure.Direction
import org.apache.tinkerpop.gremlin.structure.T
import org.apache.commons.configuration.BaseConfiguration
import java.util.Set
import java.text.DateFormat
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Iterator
import java.lang.Iterable
import java.util.concurrent.atomic.AtomicLong
import scala.Array
import scala.collection.mutable.ArrayBuffer
import com.tinkerpop.blueprints.Vertex
//import com.tinkerpop.blueprints._
import com.tinkerpop.blueprints.{Graph=>BPGraph}
import com.thinkaurelius.titan.core.TitanException
//import com.thinkaurelius.titan.diskstorage.locking.PermanentLockingException



object JDBCToGraph{
 
  def main(args: Array[String]): Unit = {
    
    println("开始连接Mysql数据库");
    val url = "jdbc:mysql://192.168.40.35:3306/titantest"
    val username = "root"
    val password = "YMiss8X%Zc"

    /*Driver program*/
    //构建spark 应用程序的运行环境SparkConf
    //val conf = new SparkConf().setAppName("JDBCToGraph")
    val conf = new SparkConf().setAppName("JDBCToGraph").setMaster("local[2]")
    //val conf = new SparkConf().setAppName("JDBCToGraph").setMaster("spark://master:7077")
    
    //初始化Sparkcontext
    val sc = new SparkContext(conf)  
    Class.forName("com.mysql.jdbc.Driver").newInstance()
    
    //开始读数据
    val start_time = System.currentTimeMillis()
    
    println("Application begin on " + start_time + "*****************************")

    try {
      //Executor
      val myRDD = new JdbcRDD(sc, () => DriverManager.getConnection(url, username, password),
        "select id, Person, EmailID, Phone, EmailAcount from test where ? <= id and id <= ?",
        0, 10, 2, r => (r.getInt("id"),r.getInt("Person"),r.getInt("EmailID"), r.getString("Phone"),r.getString("EmailAcount")));
      
      println("Mysql数据库已经连接成功");
      println("**********************");
	    val StartOfEmailID = 1000000;
	    myRDD.cache()
	   	val tVertexRdd: RDD[(VertexId, TVertex)] = myRDD.flatMap{ line => 
	   	  // Person Vertex
	   	  val tVertex = new TVertex("Person")
  	   	tVertex.addProperty("id",line._2.toString())
  	   	tVertex.addProperty("Person",line._2.toString())
  	   	tVertex.addProperty("Phone",line._4.toString())
  	   	
  	   	// Email Vertex
  	   	val eVertex = new TVertex("Email")
  	   	eVertex.addProperty("id",(line._3+StartOfEmailID).toString())
  	   	eVertex.addProperty("EmailID",line._3.toString())
  	   	eVertex.addProperty("EmailAcount",line._5.toString())
  	   	
  			List((line._2.toInt, tVertex),(line._3.toInt+StartOfEmailID, eVertex))
		  }
  		val tEdgeRDD: RDD[Edge[TEdge]] = myRDD.map{line => 
  		  // Edge between Person and Edge
  			val tEdge = new TEdge()
  	   	tEdge.addProperty("id",line._1.toString())
  	   	tEdge.addProperty("Person",line._2.toString())
  	   	tEdge.addProperty("EmailID",line._3.toString())
  	   	tEdge.addProperty("Phone",line._4.toString())
  	   	tEdge.addProperty("EmailAcount",line._5.toString())
  			Edge(line._2.toInt, line._3.toInt+StartOfEmailID, tEdge)
  		}
  		
  		// Create the social graph of people
  		val tGraph: Graph[TVertex, TEdge] = Graph(tVertexRdd, tEdgeRDD)
  		tGraph.cache()
  		tGraph.vertices.collect()
  		tGraph.edges.collect()
  		println("************************************************")
  		println(tGraph.vertices.count())
  		println(tGraph.edges.count())
  		println("*********************vertices***********************")
  		tGraph.vertices.foreach({case (id, tv)  =>
  		  println("--------------------------------------------------")
  		  println("id: " + id)
  		  println("tv: " + tv.toString())
  		  println("vtype: " + tv.vtype)
  		  tv.properties.foreach({t=>
  		    println(t._1+":"+t._2)
  		  })
  		})
  		println("*********************edges***************************")
  		tGraph.edges.foreach({te  =>
  		  println("--------------------------------------------------")
  		  println("te: " + te.toString())
  		  te.attr.properties.foreach({t=>
  		    println(t._1+":"+t._2)
  		  })
  		})
    
  	// Save GraphX to Titan
  	//tGraph.vertices.mapPartitions({vertexes =>
  	tGraph.vertices.mapPartitionsWithIndex({case (pID,vertexes)	=>
        val titanConf = new org.apache.commons.configuration.BaseConfiguration();
        println("开始连接Titan数据库");
        titanConf.setProperty("storage.backend","hbase");
        titanConf.setProperty("storage.hostname","192.168.40.211");
        titanConf.setProperty("storage.tablename","titan");
        val graph = TitanFactory.open(titanConf);

        println("Titan数据库已经连接成功");
        var tx = graph.newTransaction();
        
        //println("count="+vertexes.count({_=>true}))
        val result = vertexes.map {case(vid,vertex) => 
          println("*******************"+pID);
          println("vid:"+vid);
          var addedVertex =  tx.addVertex(T.label, vertex.vtype);
          vertex.properties.foreach({t=>
    		    addedVertex.property(t._1,t._2);
    		  })
          //List.empty.iterator 
    		  vid
        }.reduce(_+_)
        println("######################"+result+"#########"+pID)
        tx.commit()
        graph.close()
        
  	    List.empty.iterator 
  	}).count()
  	tGraph.triplets.mapPartitions({triplet =>
  	    
  	    List.empty.iterator 
  	})
  	
  	
     val end_time = System.currentTimeMillis()
     val total_seconds = (end_time - start_time)/1000;
  		 		     
    } 
    catch {
          case ex : java.util.NoSuchElementException => {
             println("####--NoSuchElement--#####");
          }
          case ex : TitanException =>{
             println("####--TitanException--#####");
          }
     }finally{
          //tx.commit();
          //tx.close()
          println("end");   
          //关闭Sparkcontext
          sc.stop();
     }
   
   case class TVertex(vtype:String) {
     var properties = Map[String,String]()
     def addProperty(name:String,value:String) {
       properties += (name->value)
     }
   }
   
   case class TEdge() {
     var properties = Map[String,String]()
     def addProperty(name:String,value:String) {
       properties += (name->value)
     }
   }
   
  }
}