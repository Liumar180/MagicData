package com.integrity.dataSmart.titanGraph.dao;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections.IteratorUtils;
import org.springframework.jdbc.core.support.JdbcDaoSupport;
import org.springframework.orm.hibernate3.support.HibernateDaoSupport;

import com.integrity.dataSmart.common.DataType;
import com.integrity.dataSmart.titanGraph.bean.QqGroupsBeans;
import com.integrity.dataSmart.titanGraph.bean.qqBeans;
import com.integrity.dataSmart.util.titan.TitanGraphUtil;
import com.thinkaurelius.titan.core.TitanGraph;
import com.thinkaurelius.titan.core.TitanMultiVertexQuery;
import com.thinkaurelius.titan.core.TitanVertex;
import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

public class SearchQqRelationDaoImp extends JdbcDaoSupport implements SearchQqRelationDao{
	private TitanGraph graph = TitanGraphUtil.getInstance().getTitanGraph();
	
	@Override
	public List<qqBeans> queryQqFriends(String qq){
		List<qqBeans> list = new ArrayList<qqBeans>();
		try{
			StringBuffer sb = new StringBuffer();
		    sb.append("SELECT id as id,QQNUM as qqNum,FRIENDNUM as friendNum,FRIENDREMARK as friendRemark FROM TB_RNS_QQ_FRIENDLIST WHERE 1=1");
			if("".equals(qq)){
				throw new Exception("qq号码为空！");
			}else{
				sb.append("AND QQNUM="+qq);
			}
			list = this.getJdbcTemplate().queryForList(sb.toString());
		}catch(Exception e){
			e.printStackTrace();
		}
		return list;
	}
	@Override
	public List<QqGroupsBeans> queryQqGroups(String qq) {
		// TODO Auto-generated method stub
		return null;
	}
	
	/**
	 * 根据qq查询群组关系
	 * @param qq qq号码
	 * @return List中的每个List的第一个为群组后面为群成员
	 */
	@Override
	public List<List<Vertex>> findGroupRelativeByqqNum(String qq) {
		//用于群组去重
		List<String> temp = new ArrayList<String>();
		List<List<Vertex>> groups = new ArrayList<List<Vertex>>();
		@SuppressWarnings("unchecked")
		Iterable<Vertex> it = graph.query().has("numid",qq).vertices();
		for (Vertex vertex : it) {
			if (DataType.IM.equals(vertex.getProperty("type"))) {//属性是IM的点
				Iterable<Vertex> groupIt = vertex.query().labels(DataType.GROUP).vertices();
				for (Vertex group : groupIt) {
					String groupNum = group.getProperty("groupnum");
					if (!temp.contains(groupNum)) {
						List<Vertex> groupList = new ArrayList<Vertex>();
						groupList.add(group);
						
						Iterable<Vertex> qqIt = group.query().labels(DataType.GROUP).vertices();
						groupList.addAll(IteratorUtils.toList(qqIt.iterator()));
						
						groups.add(groupList);
						temp.add(groupNum);
					}
				}
			}
		}
		return groups;
	}
	
	/**
	 * 根据已知节点id查询关系网络
	 * @param personId
	 * @return  List数组中共有四个对象：前两个为直接存储关系，后两个为事件关联关系
	 * 			第一个为关系边，类型为：ArrayList<Edge>;第二个为边对应的节点，类型为ArrayList<Vertex>（一个边对应一个点）
	 * 			第三个为人节点，类型为：ArrayList<Vertex>;第四个为事件节点，类型为ArrayList<ArrayList<Vertex>>
	 */
	@Override
	public List<Object> getRelativeById(long personId) {
		
		List<Object> result = new ArrayList<Object>();
		//查询出节点
		Vertex v1 = graph.getVertex(personId);
		
		/*直接查询存储的关系*/
		List<Edge> friendEdges = new ArrayList<Edge>();
		List<Vertex> friends = new ArrayList<Vertex>();
		result.add(friendEdges);
		result.add(friends);
		Iterable<Edge> edgeIterable = v1.query().direction(Direction.OUT).labels(DataType.RELATIONAL).edges();
//		Iterable<Vertex> vertexIterable = v1.query().labels(DataType.RELATIONAL).vertices();
		for (Edge edge : edgeIterable) {
			Vertex friend = edge.getVertex(Direction.IN);
			if (friend != null) {
				friendEdges.add(edge);
				friends.add(friend);
			}
		}
		
		/*根据事件查询关系*/
		ArrayList<ArrayList<Vertex>> eventList = new ArrayList<ArrayList<Vertex>>();
		ArrayList<Vertex> personList = new ArrayList<Vertex>();
		//查询出所有邻居节点
		TitanMultiVertexQuery mq = graph.multiQuery();
		mq.direction(Direction.BOTH).labels(DataType.ALLLABEL);
		int count = 0;
		for (Vertex f : v1.getVertices(Direction.BOTH, DataType.ALLLABEL)) {
			mq.addVertex((TitanVertex) f);
			count++;
		}
		result.add(personList);
		result.add(eventList);
		if (count == 0) {
			return result;
		}

		Map<String, TitanVertex> dataMap = new HashMap<String, TitanVertex>();
		Map<String, TitanVertex> vertexMap = new HashMap<String, TitanVertex>();
		Map<String, ArrayList<Vertex>> eventMap = new HashMap<String, ArrayList<Vertex>>();

		Map<TitanVertex, Iterable<TitanVertex>> results = mq.vertices();

		for (Iterator iterator = results.keySet().iterator(); iterator.hasNext();) {
			TitanVertex tv = (TitanVertex) iterator.next();
			
			Iterable<TitanVertex> tv2 = results.get(tv);

			for (Iterator iterator2 = tv2.iterator(); iterator2.hasNext();) {
				TitanVertex type = (TitanVertex) iterator2.next();
				
				String key1 = type.getId().toString() + tv.getProperty("type");
				if (!(type.getId().toString().equals(v1.getId().toString()))) {
					if (!dataMap.containsKey(key1)) {
						dataMap.put(key1, type);
						if (!vertexMap.containsKey(type.getId().toString())) {
							vertexMap.put(type.getId().toString(), type);
						}
						if (!eventMap.containsKey(type.getId().toString())) {
							ArrayList<Vertex> tt = new ArrayList<Vertex>();
							tt.add(tv);
							eventMap.put(type.getId().toString(), tt);
						}
						/**
						 * modify by liubaofen 2016/02/18
						 * 查询关系网络时，将在关系边显示的类型中，添加事件类型的显示；
						 **/
						else {
							ArrayList<Vertex> tt = eventMap.get(type.getId().toString());
							tt.add(tv);
							eventMap.put(type.getId().toString(), tt);
						}

					}
				}
			}
		}

		for (Iterator iterator = vertexMap.keySet().iterator(); iterator
				.hasNext();) {
			String key = (String) iterator.next();
			personList.add(vertexMap.get(key));
			eventList.add(eventMap.get(key));
		}

		return result;
	}



}
